/* eslint-disable */
import * as ts from 'typescript';
import { DiagnosticCategory } from 'typescript';
import { readFileSync, existsSync, statSync } from 'fs';
import { createFilter } from 'rollup-pluginutils';
import { sep } from 'path';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function endsWith(str, tail) {
    return !tail.length || str.slice(-tail.length) === tail;
}

function getDefaultOptions() {
    return {
        noEmitHelpers: true,
        module: 'es2015',
        sourceMap: true
    };
}
// Gratefully lifted from 'look-up', due to problems using it directly:
//   https://github.com/jonschlinkert/look-up/blob/master/index.js
//   MIT Licenced
function findFile(cwd, filename) {
    let fp = cwd ? `${cwd}/${filename}` : filename;
    if (existsSync(fp)) {
        return fp;
    }
    const segs = cwd.split(sep);
    let len = segs.length;
    while (len--) {
        cwd = segs.slice(0, len).join('/');
        fp = cwd + '/' + filename;
        if (existsSync(fp)) {
            return fp;
        }
    }
    return null;
}
function compilerOptionsFromTsConfig(typescript) {
    const cwd = process.cwd();
    const filePath = findFile(cwd, 'tsconfig.json');
    const tsconfig = filePath && typescript.readConfigFile(filePath, path => readFileSync(path, 'utf8'));
    if (!tsconfig || !tsconfig.config || !tsconfig.config.compilerOptions)
        return {};
    return tsconfig.config.compilerOptions;
}
function adjustCompilerOptions(typescript, options) {
    // Set `sourceMap` to `inlineSourceMap` if it's a boolean
    // under the assumption that both are never specified simultaneously.
    if (typeof options.inlineSourceMap === 'boolean') {
        options.sourceMap = options.inlineSourceMap;
        delete options.inlineSourceMap;
    }
    // Delete the `declaration` option to prevent compilation error.
    // See: https://github.com/rollup/rollup-plugin-typescript/issues/45
    delete options.declaration;
    // Use importHelpers from TypeScript.
    options.importHelpers = true;
}

function readFile(fileName) {
    return readFileSync(fileName, 'utf8');
}
function directoryExists(dirPath) {
    try {
        return statSync(dirPath).isDirectory();
    }
    catch (_a) {
        return false;
    }
}
function fileExists(filePath) {
    try {
        return statSync(filePath).isFile();
    }
    catch (_a) {
        return false;
    }
}

var resolveHost = /*#__PURE__*/Object.freeze({
    readFile: readFile,
    directoryExists: directoryExists,
    fileExists: fileExists
});

// The injected id for helpers.
const TSLIB = 'tslib';
let tslibSource;
try {
    const tslibPath = require.resolve('tslib/' + require('tslib/package.json')['module']);
    tslibSource = readFileSync(tslibPath, 'utf8');
}
catch (e) {
    console.warn('Error loading `tslib` helper library.');
    throw e;
}
typescript['default'] = typescript;
function typescript(_a) {
    var options = __rest(_a, []);
    const filter = createFilter(options.include || ['*.ts+(|x)', '**/*.ts+(|x)'], options.exclude || ['*.d.ts', '**/*.d.ts']);
    delete options.include;
    delete options.exclude;
    // Allow users to override the TypeScript version used for transpilation.
    const typescript = options.typescript || ts;
    delete options.typescript;
    // Load options from `tsconfig.json` unless explicitly asked not to.
    const tsconfig = options.tsconfig === false ? {} :
        compilerOptionsFromTsConfig(typescript);
    delete options.tsconfig;
    // Since the CompilerOptions aren't designed for the Rollup
    // use case, we'll adjust them for use with Rollup.
    adjustCompilerOptions(typescript, tsconfig);
    adjustCompilerOptions(typescript, options);
    // Merge all options.
    options = Object.assign({}, tsconfig, getDefaultOptions(), options);
    // Verify that we're targeting ES2015 modules.
    if (options.module !== 'es2015' && options.module !== 'es6') {
        throw new Error(`rollup-typescript: The module kind should be 'es2015', found: '${options.module}'`);
    }
    const parsed = typescript.convertCompilerOptionsFromJson(options, process.cwd());
    if (parsed.errors.length) {
        for (const error of parsed.errors) {
            console.error(`rollup-typescript: ${error.messageText}`);
        }
        throw new Error(`rollup-typescript: Couldnâ€™t process compiler options`);
    }
    const compilerOptions = parsed.options;
    return {
        resolveId(importee, importer) {
            if (importee === TSLIB) {
                return '\0' + TSLIB;
            }
            if (!importer)
                return null;
            let result;
            importer = importer.split('\\').join('/');
            result = typescript.nodeModuleNameResolver(importee, importer, compilerOptions, resolveHost);
            if (result.resolvedModule && result.resolvedModule.resolvedFileName) {
                if (endsWith(result.resolvedModule.resolvedFileName, '.d.ts')) {
                    return null;
                }
                return result.resolvedModule.resolvedFileName;
            }
            return null;
        },
        load(id) {
            if (id === '\0' + TSLIB) {
                return tslibSource;
            }
        },
        transform(code, id) {
            if (!filter(id))
                return null;
            const transformed = typescript.transpileModule(code, {
                fileName: id,
                reportDiagnostics: true,
                compilerOptions,
            });
            const diagnostics = transformed.diagnostics || [];
            let fatalError = false;
            for (const diagnostic of diagnostics) {
                const message = typescript.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
                if (diagnostic.file) {
                    const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
                    console.error(`${diagnostic.file.fileName}(${line + 1},${character + 1}): error TS${diagnostic.code}: ${message}`);
                }
                else {
                    console.error(`Error: ${message}`);
                }
                if (diagnostic.category === DiagnosticCategory.Error) {
                    fatalError = true;
                }
            }
            if (fatalError) {
                throw new Error(`There were TypeScript errors transpiling.`);
            }
            return {
                // Always append an import for the helpers.
                code: transformed.outputText,
                // Rollup expects `map` to be an object so we must parse the string
                map: transformed.sourceMapText ? JSON.parse(transformed.sourceMapText) : null,
            };
        }
    };
}

export default typescript;
